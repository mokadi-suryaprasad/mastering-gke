# ‚ò∏Ô∏è Day 16 ‚Äî Pod Priority & Preemption in Kubernetes

![Pod Priority & Preemption](https://kubernetes.io/images/docs/pod-priority-preemption.svg)

## üéØ Objective
Learn how Kubernetes decides **which Pods are more important** when resources are low using **Pod Priority and Preemption**.

---

## üß† Why Pod Priority & Preemption?

In a Kubernetes cluster, resources (CPU, memory) may become scarce.  
Kubernetes needs a way to **decide which Pods to schedule first** and **which Pods can be evicted**.

- **Pod Priority** ‚Üí Assigns an integer value to a Pod to indicate importance. Higher priority = more important.
- **Preemption** ‚Üí If a high-priority Pod cannot be scheduled due to lack of resources, Kubernetes **evicts low-priority Pods** to make space.

This ensures critical workloads run even under resource constraints.

---

## üß© Step 1: Enable Priority and Preemption

1. Verify that **PriorityClass** is supported in your cluster (GKE supports it by default).
2. You can create custom PriorityClasses to assign priorities to Pods.

### Example: Create a PriorityClass
```yaml
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: high-priority
value: 1000
globalDefault: false
description: "This is a high-priority class."
```

```yaml
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: low-priority
value: 100
globalDefault: false
description: "This is a low-priority class."
```

Apply it:
```bash
kubectl apply -f high-priority-class.yaml
kubectl apply -f low-priority-class.yaml
kubectl get priorityclass
```

Output:
```
NAME            VALUE   GLOBAL-DEFAULT   AGE
high-priority   1000    false            1m
low-priority    100     false            1m
system-node-critical 2000000000 true     10d
system-cluster-critical 2000000000 true   10d
```

---

## ‚öôÔ∏è Step 2: Assign Priority to Pods

### High-priority Pod
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: critical-pod
spec:
  priorityClassName: high-priority
  containers:
  - name: nginx
    image: nginx
    resources:
      requests:
        cpu: "500m"
        memory: "256Mi"
```
### Low-priority Pod
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: noncritical-pod
spec:
  priorityClassName: low-priority
  containers:
  - name: nginx
    image: nginx
    resources:
      requests:
        cpu: "500m"
        memory: "256Mi"
```

---

## ‚öôÔ∏è Step 3: Observe Preemption

1. Fill the cluster with low-priority Pods until resources are scarce.
2. Deploy a **high-priority Pod** that cannot schedule due to lack of resources.
3. Kubernetes will **evict one or more low-priority Pods** to make room for the high-priority Pod.

Check status:
```bash
kubectl get pods -o wide
kubectl describe pod critical-pod
```

You‚Äôll see that **noncritical Pods were evicted** and critical Pod is scheduled.

---

## üß© Step 4: Real-World Use Cases

| Scenario | Example |
|----------|---------|
| üß† Critical workloads | Run payment gateway, database, or API services with high priority |
| ‚ö° Burst workloads | High-priority batch jobs or ML workloads that must run |
| üí∞ Cost-sensitive | Noncritical workloads (dev/test) can be low priority and evicted if needed |
| ‚òÅÔ∏è Multi-tenant clusters | Ensure important tenants‚Äô workloads are scheduled first |

---

## üßπ Step 5: Clean Up

```bash
kubectl delete pod critical-pod noncritical-pod
kubectl delete priorityclass high-priority low-priority
```

---

## üìò Summary

| Concept | Description |
|---------|-------------|
| **Pod Priority** | Numeric value indicating Pod importance |
| **Preemption** | Evict lower-priority Pods to schedule higher-priority Pods |
| **PriorityClass** | Defines a reusable class for assigning Pod priorities |
| **Requests & Limits** | Combined with Priority, determines if Pod can be scheduled |
| **Eviction** | Automatic removal of low-priority Pods when resources are insufficient |

---

## üéì Hands-On Tips for GKE

1. Use **PriorityClass** to separate critical vs non-critical workloads.
2. Combine **Pod Priority + Node Affinity + Taints/Tolerations** for robust scheduling policies.
3. Monitor cluster resource usage (`kubectl top nodes/pods`) to test preemption behavior.
